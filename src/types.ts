import { SerializedError } from "@reduxjs/toolkit";
import { FetchBaseQueryError } from "@reduxjs/toolkit/dist/query";
import { ReactElement } from "react";

export type AllNever<
  TQueries,
  TDeferred,
  TPayload,
  TReturn = never
> = TQueries | TDeferred | TPayload | TReturn extends never
  ? true
  : false;

export type AllEql<
  TQueries,
  E_TQueries,
  TDeferred,
  E_TDeferred,
  TPayload,
  E_TPayload
> = TQueries extends E_TQueries
  ? TDeferred extends E_TDeferred
    ? TPayload extends E_TPayload
      ? true
      : false
    : false
  : false;

/** Result of a RTK useQuery hook */
export type UseQueryResult<T> = {
  // Base query state
  /** Arguments passed to the query */
  originalArgs?: unknown;
  /** The latest returned result regardless of hook arg, if present */
  data?: T;
  /** The latest returned result for the current hook arg, if present */
  currentData?: T;
  /** Error result if present */
  error?: unknown;
  /** A string generated by RTK Query */
  requestId?: string;
  /** The name of the given endpoint for the query */
  endpointName?: string;
  /** Timestamp for when the query was initiated */
  startedTimeStamp?: number;
  /** Timestamp for when the query was completed */
  fulfilledTimeStamp?: number;

  // Derived request status booleans
  /** Query has not started yet */
  isUninitialized: boolean;
  /** Query is currently loading for the first time. No data yet. */
  isLoading: boolean;
  /** Query is currently fetching, but might have data from an earlier request. */
  isFetching: boolean;
  /** Query has data from a successful load */
  isSuccess: boolean;
  /** Query is currently in an "error" state */
  isError: boolean;

  /** A function to force refetch the query */
  refetch: () => void;
};

/** _X are types that are extended from in the generics */
export type _TQueries =
  | Record<string, UseQueryResult<unknown>>
  | never;
export type _TDeferred =
  | Record<string, UseQueryResult<unknown>>
  | never;
export type _TPayload = unknown | never;
export type _TProps = Record<string, unknown>;
export type _TReturn = unknown;

export type MakeDataRequired<T extends _TQueries> = {
  // @ts-ignore: TS2536: Type '"data"' cannot be used to index type 'T[K]'.
  [K in keyof T]: T[K] & { data: NonNullable<T[K]["data"]> };
};

export type DataShapeInput<
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload
> = {
  queries?: TQueries;
  deferredQueries?: TDeferred;
  payload?: TPayload;
};

export type ResolveDataShape<
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload
> = {
  queries: TQueries extends never ? never : TQueries;
  deferredQueries: TDeferred extends never ? never : TDeferred;
  payload: TPayload extends never ? never : TPayload;
};

export type ResolveLoadedDataShape<
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload
> = ResolveDataShape<
  MakeDataRequired<TQueries>,
  TDeferred,
  TPayload
>;

/** Use: `(...args: OptionalGenericArg<T>) => void;`
 * Allows either `T` or `none` for the parameter
 */
export type OptionalGenericArg<T> = T extends never ? [] : [T];

export type LoaderTransformFunction<
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload,
  TReturn extends unknown
> = (
  data: ResolveLoadedDataShape<TQueries, TDeferred, TPayload>
) => TReturn;

export type CreateUseLoaderArgs<
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload,
  TReturn extends _TReturn,
  TArg = never
> = {
  /** Should return a list of RTK useQuery results.
   * Example:
   * ```typescript
   * (args: Args) => ({
   *    queries: {
   *      pokemon: useGetPokemonQuery(args.pokemonId),
   *    }
   * })
   * ```
   */
  useQueries: (
    ...args: OptionalGenericArg<TArg>
  ) => DataShapeInput<TQueries, TDeferred, TPayload>;
  /** Transforms the output of the queries */
  transform?: (
    data: ResolveLoadedDataShape<TQueries, TDeferred, TPayload>
  ) => TReturn;
};

export type UseLoader<
  TArg,
  TReturn,
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload
> = {
  (...args: OptionalGenericArg<TArg>): UseQueryResult<TReturn>;
  original_args: CreateUseLoaderArgs<
    TQueries,
    TDeferred,
    TPayload,
    TReturn,
    TArg
  >;
};
export type ComponentWithLoaderData<
  TProps extends Record<string, any>,
  TReturn extends unknown
> = (props: TProps, loaderData: TReturn) => ReactElement;

/** Use: `InferLoaderData<typeof loader>`. Returns the return-value of the given loader's aggregated query. */
export type InferLoaderData<T> = T extends Loader<
  any | never,
  infer InferA,
  any | never,
  any | never,
  any | never,
  any | never
>
  ? InferA
  : T extends Loader<any, infer InferB, never, any, any, any>
  ? InferB
  : T extends Loader<any, infer InferC, never, never, any, any>
  ? InferC
  : T extends Loader<any, infer InferD, never, never, never, any>
  ? InferD
  : T extends Loader<
      any,
      infer InferE,
      never,
      never,
      never,
      never
    >
  ? InferE
  : T extends Loader<any, infer InferF, any, never, never, never>
  ? InferF
  : T extends Loader<any, infer InferG, any, any, never, never>
  ? InferG
  : T extends Loader<any, infer InferH, any, any, any, never>
  ? InferH
  : T extends Loader<any, infer InferI, any, never, any, any>
  ? InferI
  : T extends Loader<any, infer InferJ, any, never, never, any>
  ? InferJ
  : never;

export type Component<TProps extends Record<string, any>> = (
  props: TProps
) => ReactElement;

export type WhileFetchingArgs<
  TProps extends unknown,
  TReturn extends unknown
> = {
  /** Will be prepended before the component while the query is fetching */
  prepend?: (props: TProps, data?: TReturn) => ReactElement;
  /** Will be appended after the component while the query is fetching */
  append?: (props: TProps, data?: TReturn) => ReactElement;
};

export type CustomLoaderProps<T = unknown> = {
  /** What the loader requests be rendered while fetching data */
  onFetching?: React.ReactElement;
  /** What the loader requests be rendered while fetching data */
  whileFetching?: {
    /** Should be appended to the success result while fetching */
    append?: React.ReactElement;
    /** Should be prepended to the success result while fetching */
    prepend?: React.ReactElement;
  };
  /** What the loader requests be rendered when data is available */
  onSuccess: (data: T) => React.ReactElement;
  /** What the loader requests be rendered when the query fails */
  onError?: (
    error: SerializedError | FetchBaseQueryError
  ) => JSX.Element;
  /** What the loader requests be rendered while loading data */
  onLoading?: React.ReactElement;
  /** The joined query for the loader */
  query: UseQueryResult<T>;
};

export type CreateLoaderArgs<
  TProps extends unknown,
  TQueries extends _TQueries,
  TDeferred extends _TDeferred,
  TPayload extends _TPayload,
  TReturn extends unknown,
  TArg = never
> = Partial<
  CreateUseLoaderArgs<
    TQueries,
    TDeferred,
    TPayload,
    TReturn,
    TArg
  >
> & {
  /** Generates an argument for the `queries` based on component props */
  queriesArg?: (props: TProps) => TArg;
  /** Determines what to render while loading (with no data to fallback on) */
  onLoading?: (props: TProps) => ReactElement;
  /** Determines what to render when query fails. */
  onError?: (
    props: TProps,
    error: FetchBaseQueryError | SerializedError,
    joinedQuery: UseQueryResult<undefined>
  ) => ReactElement;
  /** @deprecated Using onFetching might result in loss of internal state. Use `whileFetching` instead, or pass the query to the component */
  onFetching?: (
    props: TProps,
    renderBody: () => ReactElement
  ) => ReactElement;
  /** Determines what to render besides success-result while query is fetching. */
  whileFetching?: WhileFetchingArgs<TProps, TReturn>;
  /** The component to use to switch between rendering the different query states. */
  loaderComponent?: Component<CustomLoaderProps>;
};

export type CreateLoader<
  TProps extends unknown,
  TQueries extends _TQueries = never,
  TDeferred extends _TDeferred = never,
  TPayload extends _TPayload = never,
  TReturn extends unknown = MakeDataRequired<TQueries>,
  TArg = never
> = (
  args: CreateLoaderArgs<
    TProps,
    TQueries,
    TDeferred,
    TPayload,
    TReturn,
    TArg
  >
) => Loader<
  TProps,
  TReturn,
  TQueries,
  TDeferred,
  TPayload,
  TArg
>;

export type Loader<
  TProps extends unknown,
  TReturn extends unknown,
  TQueries extends _TQueries = never,
  TDeferred extends _TDeferred = never,
  TPayload extends _TPayload = never,
  TArg = never
> = {
  /** A hook that runs all queries and returns aggregated result */
  useLoader: UseLoader<
    TArg,
    TReturn,
    TQueries,
    TDeferred,
    TPayload
  >;
  /** Generates an argument for the `queries` based on component props */
  queriesArg?: (props: TProps) => TArg;
  /** Determines what to render while loading (with no data to fallback on) */
  onLoading?: (props: TProps) => ReactElement;
  /** Determines what to render when query fails. */
  onError?: (
    props: TProps,
    error: SerializedError | FetchBaseQueryError,
    joinedQuery: UseQueryResult<undefined>
  ) => ReactElement;
  /** @deprecated Using onFetching might result in loss of internal state. Use `whileFetching` instead, or pass the query to the component */
  onFetching?: (
    props: TProps,
    renderBody: () => ReactElement
  ) => ReactElement;
  /** Determines what to render besides success-result while query is fetching. */
  whileFetching?: WhileFetchingArgs<TProps, TReturn>;
  /** Returns a new `Loader` extended from this `Loader`, with given overrides. */
  extend: <
    E_TQueries extends _TQueries = TQueries,
    E_TDeferred extends _TDeferred = TDeferred,
    E_TPayload extends _TPayload = TPayload,
    E_TReturn extends unknown = AllEql<
      TQueries,
      E_TQueries,
      TDeferred,
      E_TDeferred,
      TPayload,
      E_TPayload
    > extends true
      ? TReturn
      : ResolveLoadedDataShape<
          E_TQueries,
          E_TDeferred,
          E_TPayload
        >,
    E_TProps extends unknown = TProps,
    E_TArg = TArg
  >(
    newLoader: Partial<
      CreateLoaderArgs<
        E_TProps,
        E_TQueries,
        E_TDeferred,
        E_TPayload,
        E_TReturn,
        E_TArg
      >
    >
  ) => Loader<
    E_TProps,
    E_TReturn,
    E_TQueries,
    E_TDeferred,
    E_TPayload,
    E_TArg
  >;
  /** The component to use to switch between rendering the different query states. */
  LoaderComponent: Component<CustomLoaderProps>;
};

export type CreateQueryGetter<T extends unknown> =
  () => Promise<T>;

export type CreateQueryReducerAction<T extends unknown> =
  | {
      type: "load";
    }
  | {
      type: "fetch";
    }
  | {
      type: "error";
      payload: {
        error: unknown;
      };
    }
  | {
      type: "success";
      payload: {
        data: T;
      };
    };

export type ConsumerProps<T extends Record<string, unknown>> =
  Record<string, unknown> & T;

/************************************************/
/*  Legacy/unused, for backwards compatibility  */
/************************************************/
export type WithLoaderArgs<
  TProps extends unknown,
  TReturn extends unknown,
  TArg = never
> = Loader<TProps, TReturn, _TQueries, _TQueries, unknown, TArg>;
